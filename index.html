<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gorilla Quest: Jungle King</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #87CEEB; /* Sky Blue */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            color: white;
            text-shadow: 2px 2px 0 #000;
            font-weight: bold;
            font-size: 24px;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: white;
            text-shadow: 1px 1px 2px black;
            font-size: 18px;
            pointer-events: none;
            opacity: 0.9;
        }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 40px;
            border-radius: 10px;
            display: none;
            border: 4px solid #FFD700;
            z-index: 10;
        }
        button {
            background: #FFD700;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            border-radius: 5px;
            cursor: pointer;
            color: #3e2723;
            font-weight: bold;
            margin-top: 20px;
        }
        button:hover {
            background: #ffecb3;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div>üçå <span id="score">0</span></div>
        <div id="ammo-ui" style="display:none; color: yellow;">‚ö° AMMO: <span id="ammo">0</span></div>
        <div id="health-ui" style="color: red; margin-top: 5px;">‚ù§Ô∏è <span id="health">3</span></div>
    </div>

    <div id="instructions">
        Arrow Keys to Run ‚Ä¢ SPACE to Jump ‚Ä¢ 'D' to Throw Banana<br>
        Jump on branches! Avoid the Snake's poison!
    </div>

    <div id="game-over">
        <h1 id="go-title">GAME OVER</h1>
        <p id="go-msg">The jungle claimed you.</p>
        <button id="restart-btn" onclick="resetGame()">Try Again</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * GORILLA QUEST: JUNGLE KING
 * A classic platformer.
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- Game Constants ---
const GRAVITY = 0.8;
const FRICTION = 0.85; // Ground friction
const AIR_RESISTANCE = 0.95;
const SPEED = 1.5; // Acceleration
const MAX_SPEED = 12;
const JUMP_FORCE = -22;
const CAMERA_OFFSET_X = 300;

// --- Assets ---
const SPRITES = {
    gorilla: "ü¶ç",
    gorillaRun: "ü¶ç",
    gorillaJump: "ü¶ç", // Could use different emoji if available
    banana: "üçå",
    bunch: "üçåüçå",
    branch: "üå≥", // Acts as platform
    snake: "üêç",
    snakeAttack: "üêç",
    poison: "ü§¢", 
    poof: "üí®"
};

// --- Game State ---
let gameState = 'playing';
let score = 0;
let ammo = 0;
let frameCount = 0;

let camera = { x: 0, y: 0 };
let width, height;
let floorY;

// --- Inputs ---
const keys = {
    left: false,
    right: false,
    space: false,
    d: false
};

// --- Entities ---
let player;
let platforms = []; // Replaces branches array conceptually, though we still draw trees
let bananas = [];
let particles = [];
let projectiles = [];
let enemyProjectiles = []; // Poison
let boss = null;

// --- Audio ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    
    if (type === 'jump') {
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(300, now + 0.1);
        gainNode.gain.setValueAtTime(0.2, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
    } else if (type === 'throw') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.linearRampToValueAtTime(100, now + 0.2);
        gainNode.gain.setValueAtTime(0.2, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
    } else if (type === 'coin') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.setValueAtTime(800, now + 0.05);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === 'hit') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.linearRampToValueAtTime(50, now + 0.1);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
    } else if (type === 'hiss') {
        // White noise hit for hiss
        osc.type = 'sawtooth'; 
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    }
}

// --- Classes ---

class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.width = 40;
        this.height = 40;
        this.onGround = false;
        this.facingRight = true;
        this.health = 3;
        this.invincible = 0;
        this.color = 'black';
    }

    update() {
        if (this.invincible > 0) this.invincible--;

        // Input Movement
        if (keys.left) {
            this.vx -= SPEED;
            this.facingRight = false;
        }
        if (keys.right) {
            this.vx += SPEED;
            this.facingRight = true;
        }

        // Jump
        if (keys.space && this.onGround) {
            this.vy = JUMP_FORCE;
            this.onGround = false;
            playSound('jump');
            createParticles(this.x, this.y + 20, 5, '#8D6E63'); // Dust
        }

        // Physics
        this.vy += GRAVITY;
        this.vx *= this.onGround ? FRICTION : AIR_RESISTANCE;
        
        // Cap Speed
        if (this.vx > MAX_SPEED) this.vx = MAX_SPEED;
        if (this.vx < -MAX_SPEED) this.vx = -MAX_SPEED;

        this.x += this.vx;
        this.y += this.vy;

        // Ground Collision
        this.onGround = false;
        
        // Check Platforms (Tree canopies)
        // Simple AABB collision for platforms (one way, fall through from bottom is fine usually but let's make them solid top)
        for (let p of platforms) {
            // Check if falling down onto platform
            if (this.vy > 0 && 
                this.y + 20 >= p.y - 20 && 
                this.y - 20 < p.y - 20 &&
                this.x > p.x - 60 && this.x < p.x + 60) {
                    this.y = p.y - 40; // Sit on top of tree center
                    this.vy = 0;
                    this.onGround = true;
            }
        }

        // Check Floor
        if (this.y > floorY - 20) {
            this.y = floorY - 20;
            this.vy = 0;
            this.onGround = true;
        }

        // Boundary
        if (this.x < 0) { this.x = 0; this.vx = 0; }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x - camera.x, this.y - camera.y);
        
        // CORRECTION: The Gorilla emoji faces LEFT by default.
        // So we flip it when facing RIGHT to look forward.
        if (this.facingRight) ctx.scale(-1, 1);

        ctx.font = "40px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        // Blink if hurt
        if (this.invincible > 0 && Math.floor(frameCount / 4) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }
        
        ctx.fillText(SPRITES.gorilla, 0, 0);
        ctx.restore();
    }
    
    shoot() {
        if (ammo > 0) {
            const dir = this.facingRight ? 1 : -1;
            projectiles.push(new Projectile(this.x, this.y, dir * 20, -2, 'banana'));
            ammo--;
            playSound('throw');
            updateUI();
        }
    }
}

class Projectile {
    constructor(x, y, vx, vy, type) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.type = type; // 'banana' or 'poison'
        this.active = true;
        this.rotation = 0;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += 0.2;

        if (this.type === 'banana') {
            this.vy += 0.5; // Gravity
        } else if (this.type === 'poison') {
            // Poison moves straight or slight wave
            // No gravity
        }

        // Out of bounds
        if (this.y > height + 100 || Math.abs(this.x - camera.x) > width + 200) {
            this.active = false;
        }
    }
    draw() {
        const sx = this.x - camera.x;
        ctx.save();
        ctx.translate(sx, this.y - camera.y);
        ctx.rotate(this.rotation);
        ctx.font = "25px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.type === 'banana' ? SPRITES.banana : SPRITES.poison, 0, 0);
        ctx.restore();
    }
}

class Branch {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    draw() {
        const screenX = this.x - camera.x;
        if (screenX < -100 || screenX > width + 100) return;

        ctx.font = "60px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(SPRITES.branch, screenX, this.y - camera.y);
    }
}

class Banana {
    constructor(x, y, isBunch = false) {
        this.x = x;
        this.y = y;
        this.isBunch = isBunch;
        this.collected = false;
        this.bobOffset = Math.random() * Math.PI * 2;
    }
    
    update() {
        if (this.collected) return;
        this.y += Math.sin(frameCount * 0.1 + this.bobOffset) * 0.5;

        // Collision
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        if (dx*dx + dy*dy < 2500) { // Approx dist
            this.collected = true;
            score += this.isBunch ? 50 : 10;
            if (this.isBunch) {
                ammo += 5;
                createParticles(this.x, this.y, 20, 'gold');
                playSound('powerup');
            } else {
                createParticles(this.x, this.y, 5, 'yellow');
                playSound('coin');
            }
            updateUI();
        }
    }

    draw() {
        if (this.collected) return;
        const screenX = this.x - camera.x;
        if (screenX < -50 || screenX > width + 50) return;

        ctx.font = "30px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.isBunch ? SPRITES.bunch : SPRITES.banana, screenX, this.y - camera.y);
    }
}

class SnakeBoss {
    constructor(x, y) {
        this.x = x;
        this.y = y; // Ground level
        this.health = 100;
        this.maxHealth = 100;
        this.state = 'idle'; 
        this.timer = 0;
        this.width = 120;
        this.height = 100;
        this.vx = 0;
    }

    update() {
        if (gameState !== 'boss') return;
        
        this.timer++;

        // Face player
        const facingLeft = player.x < this.x;

        if (this.state === 'idle') {
            if (this.timer > 100) {
                this.state = Math.random() > 0.5 ? 'hiss' : 'charge';
                this.timer = 0;
            }
        } 
        else if (this.state === 'hiss') {
            // Shoot poison
            if (this.timer === 30) {
                playSound('hiss');
                const pDir = facingLeft ? -1 : 1;
                // Low projectile (jump over)
                enemyProjectiles.push(new Projectile(this.x, this.y - 20, pDir * 10, 0, 'poison'));
                // High projectile (duck/stay still - though no duck implemented, so just gap)
                // Let's stick to low jumpable projectiles for now
            }
            if (this.timer > 60) {
                this.state = 'idle';
                this.timer = 0;
            }
        }
        else if (this.state === 'charge') {
            // Slide towards player
            if (this.timer < 50) {
                this.x += facingLeft ? -8 : 8;
            } else {
                this.state = 'idle';
                this.timer = 0;
            }
        }

        // Collision with Player
        if (player.invincible <= 0) {
            const dist = Math.hypot(player.x - this.x, player.y - this.y);
            if (dist < 80) {
                playerHurt();
            }
        }

        // Collision with Bananas
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            const dist = Math.hypot(p.x - this.x, p.y - this.y);
            if (dist < 80 && p.type === 'banana') {
                this.takeDamage(10);
                p.active = false;
                createParticles(this.x, this.y, 5, 'lightgreen'); // Snake blood?
                playSound('hit');
            }
        }
    }

    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
            winGame();
        }
    }

    draw() {
        const sx = this.x - camera.x;
        
        // Health Bar
        ctx.fillStyle = 'red';
        ctx.fillRect(sx - 50, this.y - camera.y - 100, 100, 10);
        ctx.fillStyle = '#0f0';
        ctx.fillRect(sx - 50, this.y - camera.y - 100, 100 * (this.health / this.maxHealth), 10);

        ctx.font = "100px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        ctx.save();
        ctx.translate(sx, this.y - camera.y - 20);
        if (player.x > this.x) ctx.scale(-1, 1); // Look at player
        
        // Bob effect
        const bob = Math.sin(frameCount * 0.2) * 10;
        
        ctx.fillText(SPRITES.snake, 0, bob);
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10;
        this.life = 1.0;
        this.size = Math.random() * 5 + 2;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.5;
        this.life -= 0.05;
    }
    draw() {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - camera.x, this.y - camera.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

// --- Level Generation ---

function generateLevel() {
    platforms = [];
    bananas = [];
    projectiles = [];
    enemyProjectiles = [];
    particles = [];
    
    let currentX = 400;
    const endX = 3500;
    
    // Create trees/platforms
    while(currentX < endX) {
        const gap = 200 + Math.random() * 300;
        currentX += gap;
        
        const platformY = height - 150 - (Math.random() * 100);
        
        // Add Tree Platform
        platforms.push(new Branch(currentX, platformY));
        
        // Add Bananas on top
        if (Math.random() > 0.3) {
            bananas.push(new Banana(currentX, platformY - 60));
        }
        
        // Add Bunches (Ammo) in air (jump targets)
        if (Math.random() > 0.7) {
            bananas.push(new Banana(currentX + 100, platformY - 150, true));
        }
        
        // Add ground bananas
        if (Math.random() > 0.5) {
             bananas.push(new Banana(currentX + 150, height - 80));
        }
    }

    // Boss
    boss = new SnakeBoss(4000, height - 70);
    floorY = height - 50;
    
    player = new Player(100, floorY - 20);
}

// --- Core Functions ---

function init() {
    resize();
    window.addEventListener('resize', resize);
    
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    // Touch controls
    canvas.addEventListener('touchstart', (e) => {
        if (e.touches[0].clientX < width / 2) keys.space = true; // Left side jump
        else keys.d = true; // Right side shoot
        // Basic touch movement not implemented for simplicity, relying on keyboard mostly or external joystick lib
    });

    resetGame();
    loop();
}

function handleKeyDown(e) {
    if (gameState === 'gameover' && e.code === 'Space') {
        resetGame();
        return;
    }

    if (e.code === 'ArrowLeft') keys.left = true;
    if (e.code === 'ArrowRight') keys.right = true;
    if (e.code === 'Space') keys.space = true;
    if (e.code === 'KeyD') {
        if (!keys.d) {
            keys.d = true;
            player.shoot();
        }
    }
}

function handleKeyUp(e) {
    if (e.code === 'ArrowLeft') keys.left = false;
    if (e.code === 'ArrowRight') keys.right = false;
    if (e.code === 'Space') keys.space = false;
    if (e.code === 'KeyD') keys.d = false;
}

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    floorY = height - 50;
}

function resetGame() {
    gameState = 'playing';
    score = 0;
    ammo = 5; // Start with some ammo
    player && (player.health = 3);
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('instructions').style.display = 'block';
    generateLevel();
    updateUI();
}

function die(msg) {
    if (gameState === 'gameover') return;
    gameState = 'gameover';
    document.getElementById('go-msg').innerText = msg;
    document.getElementById('go-title').innerText = "GAME OVER";
    document.getElementById('restart-btn').innerText = "Try Again";
    document.getElementById('game-over').style.display = 'block';
    playSound('hit');
}

function playerHurt() {
    if (player.invincible > 0) return;
    
    player.health--;
    player.invincible = 60;
    player.vy = -10; // Knockback
    player.vx = -10;
    createParticles(player.x, player.y, 10, 'red');
    playSound('hit');
    updateUI();
    
    if (player.health <= 0) {
        die("Snake venom got you!");
    }
}

function winGame() {
    gameState = 'gameover';
    document.getElementById('go-title').innerText = "JUNGLE KING!";
    document.getElementById('go-msg').innerText = "Congratulations, you have defeated the Snake King!";
    document.getElementById('restart-btn').innerText = "Play again";
    document.getElementById('game-over').style.display = 'block';
    playSound('coin');
}

function createParticles(x, y, count, color) {
    for (let i=0; i<count; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function updateUI() {
    document.getElementById('score').innerText = score;
    document.getElementById('ammo').innerText = ammo;
    document.getElementById('ammo-ui').style.display = 'block';
    document.getElementById('health').innerText = player.health;
}

function update() {
    if (gameState === 'gameover') return;

    frameCount++;
    player.update();
    
    // Camera Follow
    if (player.x > 3500) { // Boss Arena Lock
        gameState = 'boss';
        const targetX = 3500; 
        camera.x += (targetX - camera.x) * 0.1;
    } else {
        const targetCamX = player.x - CAMERA_OFFSET_X;
        camera.x += (targetCamX - camera.x) * 0.1;
        if (camera.x < 0) camera.x = 0;
    }

    // Boss Update
    if (gameState === 'boss') boss.update();

    // Projectiles
    for (let i = projectiles.length - 1; i >= 0; i--) {
        projectiles[i].update();
        if (!projectiles[i].active) projectiles.splice(i, 1);
    }
    
    // Enemy Projectiles
    for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
        let p = enemyProjectiles[i];
        p.update();
        
        // Hit Player
        const dist = Math.hypot(p.x - player.x, p.y - player.y);
        if (dist < 40 && p.active) {
            playerHurt();
            p.active = false;
        }
        
        if (!p.active) enemyProjectiles.splice(i, 1);
    }

    // Bananas
    bananas.forEach(b => b.update());

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        if (particles[i].life <= 0) particles.splice(i, 1);
    }
}

function draw() {
    // Sky
    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, width, height);
    
    // Floor
    ctx.fillStyle = '#2E7D32';
    const floorScreenY = floorY - camera.y;
    ctx.fillRect(0, floorScreenY, width, height - floorScreenY + 100);

    // Decorative BG Trees
    ctx.fillStyle = '#1B5E20';
    for (let i=0; i<25; i++) {
        const x = (i * 300) - (camera.x * 0.3) % 300; 
        ctx.beginPath();
        ctx.moveTo(x, floorScreenY);
        ctx.lineTo(x + 60, floorScreenY - 250);
        ctx.lineTo(x + 120, floorScreenY);
        ctx.fill();
    }

    platforms.forEach(p => p.draw());
    bananas.forEach(b => b.draw());
    
    if (gameState === 'boss' || player.x > 3000) {
        boss.draw();
    }

    projectiles.forEach(p => p.draw());
    enemyProjectiles.forEach(p => p.draw());
    player.draw();
    particles.forEach(p => p.draw());
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

window.onload = init;

</script>
</body>
</html>
